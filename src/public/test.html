<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<script>
    class Node {
        constructor(m) {
            this.dataList = new Array(m + 1);
            this.linkList = new Array(m + 2);
            this.num = 0;
            this.next = null;
            this.prev = null;
            this.pNode = null;
        }
    }
    class Btree {
        constructor(compare, m) {
            this.m = m || 4;
            this.root = null;
            this.head = null;
            this.compare = compare || function (a, b) { return a - b; }
        }
        insert(value) {
            if (!this.root) {
                let node = new Node(this.m);
                node.dataList[0] = value;
                node.num++;
                this.root = node;
                this.head = node;
                return node;
            }
            let node = this._search(value, true);
            let link = null;
            let n = Math.floor(this.m / 2) || 1; //m为1时，n应该也为1
            for (let i = 0; i < node.num; i++) {
                if (this.compare(value, node.dataList[i]) === 0) {
                    return node;
                }
            }
            while (node) {
                let linkList = node.linkList;
                let dataList = node.dataList;
                for (let i = 0; i < node.num; i++) {
                    let data = dataList[i];
                    if (this.compare(value, data) < 0) {
                        _insert(dataList, linkList, i);
                        break;
                    } else if (i === node.num - 1) {
                        _insert(dataList, linkList, i + 1);
                    }
                }
                node.num++; //关键字数量加1
                if (node.num > this.m) { //超过了最大限制
                    let newNode = new Node(this.m);
                    value = dataList[n]; //父节点需要插入的值
                    node.num = n; //关键字数量为最大值的一半
                    if (node.next) {
                        node.next.prev = newNode;
                    }
                    newNode.next = node.next;
                    node.next = newNode;
                    newNode.prev = node;
                    newNode.pNode = node.pNode;
                    link = newNode;
                    for (let i = n, j = 0; i < this.m + 1; i++, j++) { //复制数据到新节点
                        newNode.dataList[j] = dataList[i];
                        newNode.linkList[j + 1] = linkList[i + 1];
                        if (newNode.linkList[j + 1]) {
                            newNode.linkList[j + 1].pNode = newNode;
                        }
                        dataList[i] = null;
                        linkList[i + 1] = null;
                        newNode.num++;
                    }
                    if (!node.pNode) { //上溢到了根节点
                        this.root = new Node(this.m);
                        this.root.dataList[0] = value;
                        this.root.linkList[0] = node;
                        this.root.linkList[1] = newNode;
                        this.root.num = 1;
                        node.pNode = this.root;
                        newNode.pNode = this.root;
                        break;
                    }
                    node = node.pNode;
                } else {
                    break;
                }
            }

            // 在i位置插入数据
            function _insert(dataList, linkList, i) {
                for (let j = node.num; j >= i + 1; j--) { //后移元素
                    dataList[j] = dataList[j - 1];
                    linkList[j + 1] = linkList[j];
                }
                dataList[i] = value;
                linkList[i + 1] = link;
            }
        }
        delete(value) {
            let node = this._search(value);
            let result = null;
            let n = Math.floor(this.m / 2) || 1;
            if (node) {
                let dataList = node.dataList;
                node.num--;
                for (let i = 0; i < node.num; i++) {
                    if (this.compare(value, dataList[i]) === 0) {
                        result = dataList[i];
                        for (let j = i; j < node.num; j++) { //前移元素
                            dataList[j] = dataList[j + 1];
                        }
                        break;
                    }
                }
            }
            while (node && node.num < n && node.pNode) {
                let dataList = node.dataList;
                let linkList = node.linkList;
                let pNode = node.pNode;
                let pIndex = pNode.linkList.indexOf(node);
                let leftNode = pNode.linkList[pIndex - 1];
                let rightNode = pNode.linkList[pIndex + 1];
                if (leftNode && leftNode.num > n) { //从左节点借

                } else if (rightNode && rightNode.num > n) { //从右节点借

                } else if (rightNode) { //向右合并
                    let isPnode = node.linkList[0] ? 1 : 0;
                    for (let i = rightNode.num - 1; i >= 0; i--) { //右移节点
                        rightNode.dataList[node.num + isPnode + i] = rightNode.dataList[i];
                        rightNode.linkList[node.num + isPnode + i + 1] = rightNode.linkList[i + 1];
                    }
                    rightNode.linkList[node.num + isPnode] = rightNode.linkList[0];
                    for (let i = 0; i < node.num; i++) { //复制节点到右节点
                        rightNode.dataList[i] = node.dataList[i];
                        rightNode.linkList[i + 1] = node.linkList[i + 1];
                        if (rightNode.linkList[i + 1]) {
                            rightNode.linkList[i + 1].pNode = rightNode;
                        }
                    }
                    rightNode.linkList[0] = node.linkList[0];
                    if (rightNode.linkList[0]) {
                        rightNode.linkList[0].pNode = rightNode;
                    }
                    if (isPnode) { //当前节点非叶子节点，父节点下移
                        rightNode.dataList[node.num] = pNode.dataList[pIndex];
                    }
                    for (let i = pIndex; i < pNode.num; i++) { //删除父节点和左域
                        pNode.dataList[i] = pNode.dataList[i + 1];
                        pNode.linkList[i] = pNode.linkList[i + 1];
                    }
                    pNode.linkList[pNode.num] = null;
                    rightNode.num += node.num + isPnode;
                    pNode.num--;
                    if (this.head === node) {//头结点被删除
                        this.head = rightNode;
                    }
                    if (!pNode.num) { //已经到了根节点
                        this.root = rightNode;
                        return result;
                    }
                    node = pNode;
                } else if (node.prev) { //向左合并

                }
            }
            return result;
        }
        search(value) {
            return this._search(value);
        }
        createResult(result, value) {
            return null;
        }
        forEach(cb) {
            let node = this.head;
            while (node) {
                let dataList = node.dataList;
                dataList.map((item) => {
                    cb(item);
                });
                node = node.next;
            }
        }
        _search(value, isInsert) {
            let node = this.root;
            while (node) {
                let linkList = node.linkList;
                let dataList = node.dataList;
                for (let i = 0; i < this.m; i++) {
                    let res = this.compare(value, dataList[i]);
                    if (res === 0) {
                        if (linkList[i + 1]) { //右侧子节点存放了父节点
                            node = linkList[i + 1];
                            break;
                        } else {
                            return node;
                        }
                    } else if (res > 0) {
                        if (!dataList[i + 1] || this.compare(value, dataList[i + 1]) < 0) { //目标在右侧子树中
                            if (linkList[i + 1]) {
                                node = linkList[i + 1];
                                break;
                            } else {
                                return isInsert ? node : null;
                            }
                        }
                    } else { //目标在左侧子树中
                        if (linkList[i]) {
                            node = linkList[i];
                            break;
                        } else {
                            return isInsert ? node : null;
                        }
                    }
                }
            }
        }
    }
    let tree = new Btree();
    for (let i = 20; i >= 11; i--) {
        tree.insert(i);
    }
    for (let i = 1; i <= 10; i++) {
        tree.insert(i);
    }
    let head = tree.head;
    while (head) {
        console.log(head.dataList);
        head = head.next;
    }
    console.time();
    tree = new Btree();
    for (let i = 1; i <= 1000000; i++) {
        tree.insert(i);
    }
    console.timeEnd();
    let count = 0;
    head = tree.search(500);
    while (head.pNode) {
        head = head.pNode;
        count++;
    }
    console.log(count);
</script>

<body>
</body>

</html>